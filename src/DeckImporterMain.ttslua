---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Whimsical.
--- DateTime: 2021-08-19 6:38 a.m.
---

---@type ArkhamImportConfiguration

require("LoaderUi")
local Zones = require("Zones")

local RANDOM_WEAKNESS_ID = "01000"

local tags = { configuration = "import_configuration_provider" }

local Priority = {
    ERROR = 0,
    WARNING = 1,
    INFO = 2,
    DEBUG = 3
}

---@type fun(text: string)
local print_fun = print
local print_priority = Priority.INFO

---@param priority number
---@return string
function Priority.get_label(priority)
    if priority==0 then return "ERROR"
    elseif priority==1 then return "WARNING"
    elseif priority==2 then return "INFO"
    elseif priority==3 then return "DEBUG"
    else error(table.concat({"Priority", priority, "not found"}, " ")) return ""
    end
end

---@param message string
---@param priority number
local function debug_print(message, priority)
    if (print_priority >= priority) then
        print_fun("[" .. Priority.get_label(priority) .. "] " .. message)
    end
end

---@param str string
---@return string
local function fix_utf16_string(str)
    return str:gsub("\\u(%w%w%w%w)", function (match)
        return string.char(tonumber(match,16))
    end)
end

--Forward declaration
---@type Request
local Request = {}

---@type table<string, ArkhamImportTaboo>
local taboo_list = {}

---@return ArkhamImportConfiguration
local function get_configuration()
    local configuration = getObjectsWithTag(tags.configuration)[1]:getTable("configuration")
    print_priority = configuration.priority
    return configuration
end

function onLoad(script_state)
  local state = JSON.decode(script_state)
  initializeUi(state)

    local configuration = get_configuration()
    local taboo = Request.start({configuration.api_uri, configuration.taboo}, function (status)
        local json = JSON.decode(fix_utf16_string(status.text))
        for _, taboo in pairs(json) do
            ---@type <string, boolean>
            local cards = {}

            for _, card in pairs(JSON.decode(taboo.cards)) do
                cards[card.code] = true
            end

            taboo_list[taboo.id] = {
                date = taboo.date_start,
                cards = cards
            }
        end
        return true, nil
    end)

    --TODO: Remove call after verifying it's unnecessary for the taboo load
    --taboo:with(initialize, configuration)
end

function onSave()
  return JSON.encode(getUiState())
end

-- TODO: Remove after verifying this function is no longer needed with the new
-- loader logic
---@param status WebRequestStatus
---@param number number
---@param is_bonded boolean
---@return boolean, ArkhamImportCard
-- local function on_card_request(status, number, is_bonded)
--     local text = fix_utf16_string(status.text)
--
--     ---@type ArkhamImportCard
--     local card = JSON.decode(text)
--     card.count = number
--     card.is_bonded = is_bonded
--
--     return true, card
-- end

-- TODO: Remove after verifying this function is no longer needed with the new
-- loader logic. The new logic does not require any single-card calls to ADB
---@param configuration ArkhamImportConfiguration
---@param card_code string
---@param count number
---@param is_bonded boolean
---@return Request
-- local function add_card(configuration, card_code, count, is_bonded)
--     local api, card_path = configuration.api_uri, configuration.cards
--     local request = Request.start({api, card_path, card_code}, on_card_request, nil, count, is_bonded)
--     return request
-- end

-- TODO: Remove after verifying this function is no longer needed with the new
-- loader logic.  Cards are now spawned directly in the correct position, no
-- callback needed.
---@param source TTSObject
---@param count number
---@param zones ArkhamImportZone[]
---@param keep_card boolean
---@return fun(card: TTSObject)
-- local function position_card(source, count, zones, keep_card)
--     ---@param card TTSObject
--     return function (card)
--
--         for n = 1, count do
--             local zone = zones[n]
--
--             local destination = zone.is_absolute and zone.position or self:positionToWorld(zone.position)
--             local rotation = self:getRotation() + Vector(0, 0, zone.is_facedown and 180 or 0)
--             card:clone {
--                 position = destination,
--                 rotation = rotation
--             }
--         end
--
--         if keep_card then source:putObject(card) else card:destruct() end
--     end
-- end

-- TODO: Remove after verifying this function is no longer needed with the new
-- loader logic
---@param source TTSObject
---@param target_name string
---@param target_subname string
---@param count number
---@param zone ArkhamImportZone[]
-- local function process_card(source, target_name, target_subname, count, zone)
--     for _, card in ipairs(source:getObjects()) do
--         if (card.name == target_name and (not target_subname or card.description==target_subname)) then
--             source:takeObject {
--                 position = {0, 1.5, 0},
--                 index = card.index,
--                 smooth = false,
--                 callback_function = position_card(source, count, zone, true)
--             }
--             debug_print(table.concat({ "Added", count, "of", target_name}, " "), Priority.DEBUG)
--             return
--         end
--     end
--     debug_print(table.concat({ "Card not found:", target_name}, " "), Priority.WARNING)
-- end

-- TODO: Remove after verifying this function is no longer needed with the new
-- loader logic.  This function is replaced by maybeDrawRandomWeakness()
---@param source TTSObject
---@param zones ArkhamImportZone[]
-- local function random_weakness(source, zones)
--     source:shuffle()
--
--     local card = source:takeObject {
--         position = {0, 1.5, 0},
--         index = 0,
--         smooth = false,
--         callback_function = position_card(source, 1, zones, false),
--     }
--
--     broadcastToAll("Drew random basic weakness: " .. card:getName())
-- end

-- TODO: Remove after verifying this function is no longer needed with the new
-- loader logic
---@param configuration ArkhamImportConfiguration
---@param card_id string
---@param used_bindings table<string, boolean>
---@param requests Request[]
-- local function process_bindings(configuration, card_id, used_bindings, requests)
--     local bondedCards = configuration.bonded_cards[card_id]
--
--     if not bondedCards then return end
--
--     if bondedCards.code then bondedCards = {bondedCards} end
--
--     for _, bond in ipairs(bondedCards) do
--         if not used_bindings[bond.code] then
--             used_bindings[bond.code] = true
--             local result = add_card(configuration, bond.code, bond.count, true)
--
--             table.insert(requests, result)
--         end
--     end
-- end

-- TODO: Check whether this is still necessary.  If possible it is likely better
-- to handle each card individually, though this may cause issues with the count
-- in the Move command.
---@param zone string
---@param count number
---@return string[]
local function fill_zone(zone, count)
    local result = {}
    for n=1,count do
        result[n] = zone
    end
    return result
end

-- TODO: Remove after verifying this function is no longer needed with the new
-- loader logic.  This method should be replaced by the Zones object
---@param card ArkhamImportCard
---@param zone string[]
---@param override string[]
---@return string[]
-- local function get_zone_id(card, zone, override)
--     local result = {}
--     for n=1,card.count do
--         result[n] = zone[n]
--                 or override[n]
--                 or (card.is_bonded and "bonded")
--                 or (card.permanent and "permanent")
--                 or (card.subtype_name and card.subtype_name:find("Weakness") and "weakness")
--                 or (card.type_code == "investigator" and "investigator")
--                 or "default"
--     end
--
--     return result
-- end

-- TODO: Remove after verifying this function is no longer needed with the new
-- loader logic
---@param cards ArkhamImportCard[]
---@param deck ArkhamImportDeck
---@param command_manager TTSObject
---@param configuration ArkhamImportConfiguration
-- local function on_cards_ready(cards, deck, command_manager, configuration)
--     local card_bag = getObjectFromGUID(configuration.card_bag_guid)
--     local weakness_bag = getObjectFromGUID(configuration.weaknesses_bag_guid)
--     local investigator_bag = getObjectFromGUID(configuration.investigator_bag_guid)
--     local minicard_bag = getObjectFromGUID(configuration.minicard_bag_guid)
--
--     local taboo = taboo_list[deck.taboo_id] or {}
--
--     local meta = deck.meta and JSON.decode(deck.meta) or {}
--
--     for _, card in ipairs(cards) do
--         ---@type ArkhamImport_Command_HandlerArguments
--         local parameters = {
--             configuration = configuration,
--             source_guid = self:getGUID(),
--             zone = {},
--             card = card,
--         }
--
--         ---@type ArkhamImport_CommandManager_HandlerResults
--         local command_result = command_manager:call("handle", parameters)
--
--         if not command_result.is_successful then
--             debug_print(command_result.error_message, Priority.ERROR)
--             return
--         end
--
--         local card = command_result.card
--
--         if not command_result.handled then
--             local target_name, target_subname = get_card_selector(configuration.discriminators, card, taboo, meta)
--             local override = configuration.default_zone_overrides[card.code]
--
--             if type(override)=="string" then override = fill_zone(override, card.count) end
--
--             local zone = get_zone_id(card, command_result.zone, configuration.default_zone_overrides[card.code] or {})
--
--             local spawn_zones = {}
--
--             local zones = configuration.zones
--             for index, zone in ipairs(zone) do
--                 spawn_zones[index] = zones[zone]
--             end
--
--             if card.real_name == "Random Basic Weakness" then
--                 random_weakness(weakness_bag, spawn_zones)
--             elseif card.type_code == "investigator" then
--                 process_card(investigator_bag, target_name, nil, card.count, spawn_zones)
--                 process_card(minicard_bag, card.real_name, nil, card.count, spawn_zones)
--             else
--                 process_card(card_bag, target_name, target_subname, card.count, spawn_zones)
--             end
--         end
--     end
-- end

-- Callback when the deck information is received from ArkhamDB.  Parses the
-- response then applies standard transformations to the deck such as adding
-- random weaknesses and checking for taboos.  Once the deck is processed,
-- passes to load_cards to actually spawn the defined deck.
---@param deck ArkhamImportDeck
---@param player_color String Color name of the player mat to place this deck
--     on (e.g. "Red")
---@param configuration ArkhamImportConfiguration
local function on_deck_result(deck, player_color, configuration)
  -- Load the next deck in the upgrade path if the option is enabled
  if (getUiState().loadNewest and deck.next_deck ~= nil and deck.next_deck ~= "") then
    build_deck(player_color, deck.next_deck)
    return
  end

    debug_print(table.concat({ "Found decklist: ", deck.name}), Priority.INFO)

    debug_print(table.concat({"-", deck.name, "-"}), Priority.DEBUG)
    for k,v in pairs(deck) do
        if type(v)=="table" then
            debug_print(table.concat {k, ": <table>"}, Priority.DEBUG)
        else
            debug_print(table.concat {k, ": ", tostring(v)}, Priority.DEBUG)
        end
    end
    debug_print("", Priority.DEBUG)

    -- Initialize deck slot table and perform common transformations.  The order
    -- of these should not be changed, as later steps may act on cards added in
    -- each.  For example, a random weakness or investigator may have bonded
    -- cards or taboo entries, and should be present
    local slots = deck.slots
    maybeDrawRandomWeakness(slots, player_color, configuration)
    maybeAddInvestigatorCards(deck, slots)
    extractBondedCards(slots, configuration)
    checkTaboos(deck.taboo_id, slots)

    local command_manager = getObjectFromGUID(configuration.command_manager_guid)

    ---@type ArkhamImport_CommandManager_InitializationArguments
    local parameters = {
        configuration = configuration,
        description = deck.description_md,
    }

    ---@type ArkhamImport_CommandManager_InitializationResults
    local results = command_manager:call("initialize", parameters)

    if not results.is_successful then
        debug_print(results.error_message, Priority.ERROR)
        return
    end

    load_cards(slots, player_color, command_manager, configuration, results.configuration)

-- TODO: Remove call, the calls (and hence the additional callbacks) should no
-- longer be necessary
--    Request.with_all(requests, on_cards_ready, nil, deck, command_manager, results.configuration)
end

-- Checks to see if the slot list includes the random weakness ID.  If it does,
-- removes it from the deck and replaces it with the ID of a random basic
-- weakness provided by the all cards bag
-- Param slots: The slot list for cards in this deck.  Table key is the cardId,
--     value is the number of those cards which will be spawned
-- Param playerColor: Color name of the player this deck is being loaded for.
--     Used for broadcast if a weakness is added.
-- Param configuration: The API configuration object
function maybeDrawRandomWeakness(slots, playerColor, configuration)
  local all_cards_bag = getObjectFromGUID(configuration.card_bag_guid)
  local hasRandomWeakness = false
  for cardId, cardCount in pairs(slots) do
    if (cardId == RANDOM_WEAKNESS_ID) then
      hasRandomWeakness = true
      break
    end
  end
  if (hasRandomWeakness) then
    local weaknessId = all_cards_bag.call("getRandomWeaknessId")
    slots[weaknessId] = 1
    slots[RANDOM_WEAKNESS_ID] = nil
    broadcastToAll("Random basic weakness added to deck", playerColor)
  end
end

-- If the UI indicates that investigator cards should be loaded, add both the
-- investigator (XXXXX) and minicard (XXXXX-m) slots with one copy each
-- Param deck: The processed ArkhamDB deck response
-- Param slots: The slot list for cards in this deck.  Table key is the cardId,
--     value is the number of those cards which will be spawned
function maybeAddInvestigatorCards(deck, slots)
  if (getUiState().investigators) then
    local investigatorId = deck.investigator_code
    if (investigatorId == "98016") then
      log("FOUND! "..deck.id)
    end
    slots[investigatorId.."-m"] = 1
    local parallelFront = deck.meta ~= nil and deck.meta.alternate_front ~= nil and deck.meta.alternate_front ~= ""
    local parallelBack = deck.meta ~= nil and deck.meta.alternate_back ~= nil  and deck.meta.alternate_back ~= ""
    if (parallelFront and parallelBack) then
      investigatorId = investigatorId.."-p"
    elseif (parallelFront) then
      investigatorId = investigatorId.."-pf"
    elseif (parallelBack) then
      investigatorId = investigatorId.."-pb"
    end
    slots[investigatorId] = 1
  end
end

-- Process the slot list and looks for any cards which are bonded to those in
-- the deck.  Adds those cards to the slot list.
-- Param slots: The slot list for cards in this deck.  Table key is the cardId,
--     value is the number of those cards which will be spawned
-- Param configuration: The API configuration object
function extractBondedCards(slots, configuration)
  local all_cards_bag = getObjectFromGUID(configuration.card_bag_guid)
  -- Create a list of bonded cards first so we don't modify slots while iterating
  local bondedCards = { }
  for cardId, cardCount in pairs(slots) do
    local card = all_cards_bag.call("getCardById", { id = cardId })
    if (card ~= nil and card.metadata.bonded ~= nil) then
      for _, bond in ipairs(card.metadata.bonded) do
        bondedCards[bond.id] = bond.count
      end
    end
  end
  -- Add any bonded cards to the main slots list
  for bondedId, bondedCount in pairs(bondedCards) do
    slots[bondedId] = bondedCount
  end
end

-- Check the deck for any cards on its taboo list.  If they're found, replace
-- the entry in the slot with the Taboo id (i.e. "XXXX" becomes "XXXX-t")
-- Param tabooId: The deck's taboo ID, taken from the deck response taboo_id
--     field.  May be nil, indicating that no taboo list should be used
-- Param slots: The slot list for cards in this deck.  Table key is the cardId,
--     value is the number of those cards which will be spawned
function checkTaboos(tabooId, slots)
  if (tabooId) then
    for cardId, _ in pairs(taboo_list[tabooId].cards) do
      if (slots[cardId] ~= nil) then
        slots[cardId.."-t"] = slots[cardId]
        slots[cardId] = nil
      end
    end
  end
end

-- Process the slot list, which defines the card Ids and counts of cards to
-- load.  Spawn those cards at the appropriate zones, and report an error to the
-- user if any could not be loaded.
-- Param slots: Key-Value table of cardId:count.  cardId is the ArkhamDB ID of
--     the card to spawn, and count is the number which should be spawned
-- Param player_color String Color name of the player mat to place this deck
--     on (e.g. "Red")
-- Param command_manager
-- Param configuration: Loader configuration object
-- Param command_config:
function load_cards(slots, player_color, command_manager, configuration, command_config)
  local all_cards_bag = getObjectFromGUID(configuration.card_bag_guid)
  local yPos = 2
  for cardId, cardCount in pairs(slots) do
    local card = all_cards_bag.call("getCardById", { id = cardId })

    -- TODO: Process commands for the card

    if (card ~= nil) then
      local cardPos = Zones.getZonePosition(player_color, Zones.getDefaultCardZone(card.metadata))
      cardPos.y = yPos
      for i = 1, cardCount do
        spawnObjectData({
          data = card.data,
          position = cardPos,
          rotation = Zones.getDefaultCardRotation(player_color, card.metadata)})
        cardPos.y = cardPos.y + 0.25
      end
      -- Set the count to zero so we know we loaded it
      slots[cardId] = 0
    end
  end

  -- Look for any cards which haven't been loaded
  local hadError = false
  for cardId, remainingCount in pairs(slots) do
    if (remainingCount > 0) then
      hadError = true
      local request = Request.start({
          configuration.api_uri,
          configuration.cards,
          cardId},
          function(result)
            local adbCardInfo = JSON.decode(fix_utf16_string(result.text))
            local cardName = adbCardInfo.real_name
            if (cardName ~= nil) then
              if (adbCardInfo.xp ~= nil) then
                cardName = cardName.." ("..adbCardInfo.xp..")"
              end
              broadcastToAll("Card not found: "..cardName..", ArkhamDB ID "..cardId, {0.5,0.5,0.5})
            else
              broadcastToAll("Card not found in ArkhamDB, ID "..cardId, {0.5,0.5,0.5})
            end
          end)
      return request
    end
  end
  print("Deck loaded successfully!")
end

-- Test method.  Loads all decks which were submitted to ArkhamDB on a given
-- date.
function testLoadLotsOfDecks()
  local configuration = get_configuration()
  local deckList = Request.start({
    configuration.api_uri,
    "decklists/by_date",
    "2020-06-04",
  },
  function(result)
    local json = JSON.decode(result.text)
    for i, deckData in ipairs(json) do
      build_deck(getColorForTest(i), deckData.id)
    end
  end)
end

-- Rotates the player mat based on index, to spread the card stacks during
-- a mass load
function getColorForTest(index)
  if (index % 4 == 0) then
    return "Red"
  elseif (index % 4 == 1) then
    return "Orange"
  elseif (index % 4 == 2) then
    return "White"
  elseif (index % 4 == 3) then
    return "Green"
  end
end

-- Start the deck build process for the given player color and deck ID.  This
-- will retrieve the deck from ArkhamDB, and pass to a callback for processing.
-- Param player_color String Color name of the player mat to place this deck
--     on (e.g. "Red")
-- Param deck_id: ArkhamDB deck id to be loaded
function build_deck(player_color, deck_id)
    local configuration = get_configuration()
    -- Get a simple card to see if the bag indexes are complete.  If not, abort
    -- the deck load.  The called method will handle player notification.
    local all_cards_bag = getObjectFromGUID(configuration.card_bag_guid)
    local checkCard = all_cards_bag.call("getCardById", { id = "01001"})
    if (checkCard ~= nil and checkCard.data == nil) then
      return
    end

    local deck_uri = { configuration.api_uri, getUiState().private and configuration.private_deck or configuration.public_deck, deck_id }

    local deck = Request.start(deck_uri, function (status)
        if string.find(status.text, "<!DOCTYPE html>") then
            return false, table.concat({ "Private deck ", deck_id, " is not shared"})
        end

        local json = JSON.decode(status.text)

        if not json then
            return false, "Deck not found!"
        end

        return true, JSON.decode(status.text)
    end)

    deck:with(on_deck_result, player_color, configuration)
end

---@type Request
Request = {
    is_done = false,
    is_successful = false
}

--- Creates a new instance of a Request. Should not be directly called. Instead use Request.start and Request.deferred.
---@param uri string
---@param configure fun(request: Request, status: WebRequestStatus)
---@return Request
function Request:new(uri, configure)
    local this = {}

    setmetatable(this, self)
    self.__index = self

    if type(uri)=="table" then
        uri = table.concat(uri, "/")
    end

    this.uri = uri

    WebRequest.get(uri, function(status)
        configure(this, status)
    end)

    return this
end

--- Creates a new request. on_success should set the request's is_done, is_successful, and content variables.
--- Deferred should be used when you don't want to set is_done immediately (such as if you want to wait for another request to finish)
---@param uri string
---@param on_success fun(request: Request, status: WebRequestStatus, vararg any)
---@param on_error fun(status: WebRequestStatus)|nil
---@vararg any[]
---@return Request
function Request.deferred(uri, on_success, on_error, ...)
    local parameters = table.pack(...)
    return Request:new(uri, function (request, status)
        if (status.is_done) then
            if (status.is_error) then
                request.error_message = on_error and on_error(status, table.unpack(parameters)) or status.error
                request.is_successful = false
                request.is_done = true
            else
                on_success(request, status)
            end
        end
    end)
end

--- Creates a new request. on_success should return weather the resultant data is as expected, and the processed content of the request.
---@param uri string
---@param on_success fun(status: WebRequestStatus, vararg any): boolean, any
---@param on_error nil|fun(status: WebRequestStatus, vararg any): string
---@vararg any[]
---@return Request
function Request.start(uri, on_success, on_error, ...)
    local parameters = table.pack(...)
    return Request.deferred(uri, function(request, status)
        local result, message = on_success(status, table.unpack(parameters))
        if not result then request.error_message = message else request.content = message end
        request.is_successful = result
        request.is_done = true
    end, on_error, table.unpack(parameters))
end

---@param requests Request[]
---@param on_success fun(content: any[], vararg any[])
---@param on_error fun(requests: Request[], vararg any[])|nil
---@vararg any
function Request.with_all(requests, on_success, on_error, ...)
    local parameters = table.pack(...)

    Wait.condition(function ()
        ---@type any[]
        local results = {}

        ---@type Request[]
        local errors = {}

        for _, request in ipairs(requests) do
            if request.is_successful then
                table.insert(results, request.content)
            else
                table.insert(errors, request)
            end
        end

        if (#errors<=0) then
            on_success(results, table.unpack(parameters))
        elseif on_error ==nil then
            for _, request in ipairs(errors) do
                debug_print(table.concat({ "[ERROR]", request.uri, ":", request.error_message }), Priority.ERROR)
            end
        else
            on_error(requests, table.unpack(parameters))
        end
    end, function ()
        for _, request in ipairs(requests) do
            if not request.is_done then return false end
        end
        return true
    end)
end

---@param callback fun(content: any, vararg any)
function Request:with(callback, ...)
    local arguments = table.pack(...)
    Wait.condition(function ()
        if self.is_successful then
            callback(self.content, table.unpack(arguments))
        end
    end, function () return self.is_done
    end)
end
