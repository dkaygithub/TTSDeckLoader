---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Whimsical.
--- DateTime: 2021-08-23 3:50 p.m.
---

---@type Request
Request = {
    is_done = false,
    is_successful = false
}

--- Creates a new instance of a Request. Should not be directly called. Instead use Request.start and Request.deferred.
---@param uri string
---@param configure fun(request: Request, status: WebRequestStatus)
---@return Request
function Request:new(uri, configure)
    local this = {}

    setmetatable(this, self)
    self.__index = self

    if type(uri)=="table" then
        uri = table.concat(uri, "/")
    end

    this.uri = uri

    WebRequest.get(uri, function(status)
        configure(this, status)
    end)

    return this
end

--- Creates a new request. on_success should set the request's is_done, is_successful, and content variables.
--- Deferred should be used when you don't want to set is_done immediately (such as if you want to wait for another request to finish)
---@param uri string
---@param on_success fun(request: Request, status: WebRequestStatus, vararg any)
---@param on_error fun(status: WebRequestStatus)|nil
---@vararg any[]
---@return Request
function Request.deferred(uri, on_success, on_error, ...)
    local parameters = table.pack(...)
    return Request:new(uri, function (request, status)
        if (status.is_done) then
            if (status.is_error) then
                request.error_message = on_error and on_error(status, table.unpack(parameters)) or status.error
                request.is_successful = false
                request.is_done = true
            else
                on_success(request, status)
            end
        end
    end)
end

--- Creates a new request. on_success should return weather the resultant data is as expected, and the processed content of the request.
---@param uri string
---@param on_success fun(status: WebRequestStatus, vararg any): boolean, any
---@param on_error nil|fun(status: WebRequestStatus, vararg any): string
---@vararg any[]
---@return Request
function Request.start(uri, on_success, on_error, ...)
    local parameters = table.pack(...)
    return Request.deferred(uri, function(request, status)
        local result, message = on_success(status, table.unpack(parameters))
        if not result then request.error_message = message else request.content = message end
        request.is_successful = result
        request.is_done = true
    end, on_error, table.unpack(parameters))
end

---@param requests Request[]
---@param on_success fun(content: any[], vararg any[])
---@param on_error fun(requests: Request[], vararg any[])|nil
---@vararg any
function Request.with_all(requests, on_success, on_error, ...)
    local parameters = table.pack(...)

    Wait.condition(function ()
        ---@type any[]
        local results = {}

        ---@type Request[]
        local errors = {}

        for _, request in ipairs(requests) do
            if request.is_successful then
                table.insert(results, request.content)
            else
                table.insert(errors, request)
            end
        end

        if (#errors<=0) then
            on_success(results, table.unpack(parameters))
        elseif on_error ==nil then
            for _, request in ipairs(errors) do
                debugInfo(table.concat({"[ERROR]", request.uri, ":", request.error_message }), Priority.ERROR)
            end
        else
            on_error(requests, table.unpack(parameters))
        end
    end, function ()
        for _, request in ipairs(requests) do
            if not request.is_done then return false end
        end
        return true
    end)
end

---@param callback fun(request: Request, content: any, vararg any)
function Request:with(callback, ...)
    local arguments = table.pack(...)
    Wait.condition(function ()
        if self.is_successful then
            callback(self.content, table.unpack(arguments))
        end
    end, function () return self.is_done
    end)
end
